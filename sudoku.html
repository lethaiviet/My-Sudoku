<!DOCTYPE html>

<html>

<head>
    <title>My sudoku</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Add icon library -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        /* .btn {
            background-color: DodgerBlue;
            border: none;
            color: white;
            padding: 12px 16px;
            font-size: 16px;
            cursor: pointer;
        } */

        .form-select:focus {
            outline: none;
            box-shadow: none;
        }

        /* Darker background on mouse-over */
        /* .btn:hover {
            background-color: RoyalBlue;
        } */

        .btn-circle.btn-sm {
            width: 30px;
            height: 30px;
            padding: 6px 0px;
            border-radius: 15px;
            font-size: 8px;
            text-align: center;
        }

        .btn-circle.btn-md {
            width: 50px;
            height: 50px;
            padding: 7px 10px;
            border-radius: 25px;
            font-size: 10px;
            text-align: center;
        }

        .btn-circle.btn-xl {
            width: 70px;
            height: 70px;
            padding: 10px 16px;
            border-radius: 35px;
            font-size: 12px;
            text-align: center;
        }

        .btn-square-md {
            width: 80px !important;
            max-width: 100% !important;
            max-height: 100% !important;
            height: 80px !important;
            text-align: center;
            padding: 0px;
            font-size: 10px;
        }
    </style>
    <script>
        var CANVAS;
        var CTX;
        var GRID = [];
        var COUNT = 0;

        const NUM_LIST = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        const SCREEN = {
            FULL: {
                height: window.innerHeight,
                width: window.innerWidth
            },
            AREA_GAME: {
                height: 500,
                width: 1200
            }
        }

        const RATE_SCALE = 0.085;
        const SQUARE_SIZE = SCREEN.FULL.height * RATE_SCALE;

        const SUDOKU = {
            blockSize: SQUARE_SIZE,
            gridSize: SQUARE_SIZE * 9,
            textSize: SQUARE_SIZE * 0.7,
            gridStrokeStyle: 'black',
            lineStrokeStyle: 'gray',
            backgroundFillStyle: 'white',
        }

        //MAP_BLOCK contains all the vertices of block
        //Ex: MAP_BLOCK[0][0].topLeft.x is the x coordinate top left of the block at (0,0)
        var MAP_BLOCK = [];

        var matrixTopLeft = [];

        const initGame = () => {
            CANVAS = document.getElementById("canvas");
            CANVAS.width = SUDOKU.gridSize + 10;
            CANVAS.height = SUDOKU.gridSize + 10;
            CTX = CANVAS.getContext('2d');
            initMapBlock();
            initEmptyGrid();
            generateSudoku();
            drawBackGround();
            drawEntireSudoku();
            generateLevelSudoku();
        }

        const initMapBlock = () => {
            let topLeftGrid = {
                x: 5,
                y: 5
            };

            for (let i = 0; i < 10; i++) {
                MAP_BLOCK[i] = [];
            }

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    let topLeft = {
                        x: topLeftGrid.x + c * SUDOKU.blockSize,
                        y: topLeftGrid.y + r * SUDOKU.blockSize
                    };

                    let topRight = {
                        x: topLeft.x + SUDOKU.blockSize,
                        y: topLeft.y
                    };

                    let bottomLeft = {
                        x: topLeft.x,
                        y: topLeft.y + SUDOKU.blockSize
                    };

                    let bottomRight = {
                        x: topLeft.x + SUDOKU.blockSize,
                        y: topLeft.y + SUDOKU.blockSize
                    };

                    let center = {
                        x: topLeft.x + SUDOKU.blockSize * 0.5,
                        y: topLeft.y + SUDOKU.blockSize * 0.5
                    }

                    MAP_BLOCK[r][c] = {
                        topLeft: topLeft,
                        topRight: topRight,
                        bottomLeft: bottomLeft,
                        bottomRight: bottomRight,
                        center: center
                    }
                }
            }
        }

        const drawBackGround = () => {
            CTX.fillStyle = SUDOKU.backgroundFillStyle;
            CTX.fillRect(0, 0, SCREEN.FULL.width, SCREEN.FULL.height);
        }

        const drawGridSudoku = () => {
            for (let i = 0; i < 10; i++) {
                CTX.beginPath();

                if ((i) % 3 == 0) {
                    setThickLineStyle();
                } else {
                    setThinLineStyle();
                }

                CTX.moveTo(MAP_BLOCK[i][0].topLeft.x, MAP_BLOCK[i][0].topLeft.y);
                CTX.lineTo(MAP_BLOCK[i][9].topLeft.x, MAP_BLOCK[i][9].topLeft.y);
                CTX.stroke();

                CTX.moveTo(MAP_BLOCK[0][i].topLeft.x, MAP_BLOCK[0][i].topLeft.y);
                CTX.lineTo(MAP_BLOCK[9][i].topLeft.x, MAP_BLOCK[9][i].topLeft.y);
                CTX.stroke();
            }
        }

        const drawNumberIntoGrid = () => {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (GRID[r][c] == 0) continue;
                    drawNumberIntoBlock(GRID[r][c], MAP_BLOCK[r][c].center);
                }
            }
        }

        const clearEntireSudoku = () => {
            CTX.clearRect(MAP_BLOCK[0][0].topLeft.x,
                MAP_BLOCK[0][0].topLeft.y,
                SUDOKU.gridSize, SUDOKU.gridSize);
        }

        const drawEntireSudoku = () => {
            clearEntireSudoku();
            drawGridSudoku();
            drawNumberIntoGrid();
        }

        const drawNumberIntoBlock = (num, center) => {
            CTX.fillStyle = SUDOKU.gridStrokeStyle;
            CTX.font = `${SUDOKU.textSize}px Arial`
            const wText = CTX.measureText(num).width;
            const hText = CTX.measureText('M').width;
            CTX.fillText(num, center.x - wText / 2, center.y + hText / 2, wText);
            CTX.stroke();
        }

        const setThinLineStyle = () => {
            CTX.strokeStyle = SUDOKU.lineStrokeStyle;
            CTX.setLineDash([5, 5]);
            CTX.lineWidth = 1;
        }

        const setThickLineStyle = () => {
            CTX.strokeStyle = SUDOKU.gridStrokeStyle;
            CTX.setLineDash([]);
            CTX.lineWidth = 2;
        }

        const isInsideRect = (pos, topLeft, width, height) => {
            if (pos.x >= topLeft.x &&
                pos.x <= topLeft.x + width &&
                pos.y >= topLeft.y &&
                pos.y <= topLeft.y + height) {
                return true;
            }
            return false;
        }

        const isInsideSquare = (pos, topLeft, size) => {
            return isInsideRect(pos, topLeft, size, size);
        }

        const findColIdxBlockByPos = (pos) => {
            for (let i = 0; i < 9; i++) {
                if (pos.x > MAP_BLOCK[0][i].topLeft.x &&
                    pos.x < MAP_BLOCK[0][i].topRight.x) {
                    return i;
                }
            }
            return -1;
        }

        const findRowIdxBlockByPos = (pos) => {
            for (let i = 0; i < 9; i++) {
                if (pos.y > MAP_BLOCK[i][0].topLeft.y &&
                    pos.y < MAP_BLOCK[i][0].bottomLeft.y) {
                    return i;
                }
            }
            return -1;
        }

        const findIdxBlockByPos = (pos) => {
            return {
                c: findColIdxBlockByPos(pos),
                r: findRowIdxBlockByPos(pos)
            }
        }

        const fillColorBlockByIdx = (idx) => {
            drawEntireSudoku();
            CTX.fillStyle = 'rgba(255, 0, 0, 0.5)';
            CTX.fillRect(MAP_BLOCK[idx.r][idx.c].topLeft.x,
                MAP_BLOCK[idx.r][idx.c].topLeft.y,
                SUDOKU.blockSize, SUDOKU.blockSize);
        }

        const handleMouseMoveOn = (event) => {
            const pos = {
                "x": event.clientX - CANVAS.offsetLeft,
                "y": event.clientY - CANVAS.offsetTop
            };

            let isInsideRect = isInsideSquare(pos, MAP_BLOCK[0][0].topLeft, SUDOKU.gridSize);

            if (!isInsideRect) return;
            console.log(pos);
            console.log(findIdxBlockByPos(pos));

            fillColorBlockByIdx(findIdxBlockByPos(pos));
        }

        const getRandomValues = () => {
            const newArr = NUM_LIST.slice()
            for (let i = newArr.length - 1; i > 0; i--) {
                const rand = Math.floor(Math.random() * (i + 1));
                [newArr[i], newArr[rand]] = [newArr[rand], newArr[i]];
            }
            return newArr
        };

        const initEmptyGrid = () => {
            for (let r = 0; r < 9; r++) {
                GRID[r] = [];
                for (let c = 0; c < 9; c++) {
                    GRID[r][c] = 0;
                }
            }
        }

        const isFullGrid = (grid = GRID) => {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (grid[r][c] == 0) return false;
                }
            }
            return true;
        }

        const generateSudoku = () => {
            let row, col;
            for (let i = 0; i < 81; i++) {
                row = Math.floor(i / 9);
                col = i % 9;

                if (GRID[row][col] != 0) continue;

                for (const value of getRandomValues()) {
                    //check value do not exist in row
                    if (GRID[row].includes(value)) continue;

                    //check value do not exist in col
                    if (checkValueExistAtCol(GRID, col, value)) continue;

                    //check value do not exist SubGrid - 3x3 square
                    let subGrid = getSubGridAt(Math.floor(col / 3), Math.floor(row / 3));
                    if (subGrid.includes(value)) continue;

                    GRID[row][col] = value;
                    if (isFullGrid())
                        return true;
                    else {
                        if (generateSudoku())
                            return true;
                    }
                }

                break;
            }
            GRID[row][col] = 0;
        }

        const solveSudoku = (grid) => {
            let row, col;
            for (let i = 0; i < 81; i++) {
                row = Math.floor(i / 9);
                col = i % 9;

                if (grid[row][col] != 0) continue;

                for (const value of NUM_LIST) {
                    //check value do not exist in row
                    if (grid[row].includes(value)) continue;

                    //check value do not exist in col
                    if (checkValueExistAtCol(grid, col, value)) continue;

                    //check value do not exist SubGrid - 3x3 square
                    let subGrid = getSubGridAt(Math.floor(col / 3), Math.floor(row / 3), grid);
                    if (subGrid.includes(value)) continue;

                    grid[row][col] = value;
                    if (isFullGrid(grid)) {
                        COUNT++;
                        break;
                    }
                    else {
                        if (solveSudoku(grid))
                            return true;
                    }
                }

                break;
            }
            grid[row][col] = 0;
        }

        const generateLevelSudoku = () => {
            let level = 2;
            while (level > 0) {
                let col = randomIntFromInterval(0, 8);
                let row = randomIntFromInterval(0, 8);

                if (GRID[row][col] == 0) continue;
                let backup = GRID[row][col];

                //console.log(`GRID[${row}][${col}]`);
                GRID[row][col] = 0;

                let gridCopy = clone(GRID);

                COUNT = 0;
                solveSudoku(gridCopy);

                //console.count(COUNT);

                if (COUNT != 1) {
                    GRID[row][col] = backup;
                    level--;
                }
            }
            drawEntireSudoku();
        }

        const sleep = (ms) => new Promise(r => setTimeout(r, ms));

        const checkValueExistAtCol = (matrix, c, value) => {
            for (let r = 0; r < matrix.length; r++) {
                if (value == matrix[r][c]) return true;
            }
            return false;
        }

        // const getSubGridAt = (x, y) => {
        //     return
        // }

        const getSubGridAt = (x, y, grid = GRID) => {
            let arr = [];
            for (let i = 0; i < 9; i++) {
                let c = x * 3 + i % 3;
                let r = y * 3 + Math.floor(i / 3);
                arr[i] = grid[r][c];
            }
            return arr;
        }

        const checkValueExistInArray = (arr, value) => {
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] == value) return true;
            }
            return false;
        }

        const checkDuplicatedValueInArray = (arr) => {
            return new Set(arr).size != arr.length;
        }

        const checkColsAndRowsSudoku = () => {
            for (let i = 0; i < 9; i++) {
                let row = GRID[i];
                let col = GRID.map(val => val[i]);

                if (checkValueExistInArray(row, 0) ||
                    checkValueExistInArray(col, 0))
                    return false;

                if (checkDuplicatedValueInArray(row) ||
                    checkDuplicatedValueInArray(col))
                    return false;
            }
            return true;
        }

        const checkSubGridSudoku = () => {
            for (let i = 0; i < 9; i++) {
                let subGrid = getSubGridAt(Math.floor(i / 3), i % 3);
                if (checkValueExistInArray(subGrid, 0))
                    return false;

                if (checkDuplicatedValueInArray(subGrid))
                    return false;
            }
            return true;
        }

        const isGridSudokuValid = () => {
            return checkColsAndRowsSudoku() && checkSubGridSudoku();
        }

        const clone = (items) => items.map(item => Array.isArray(item) ? clone(item) : item);

        const randomIntFromInterval = (min, max) => { // min and max included 
            return Math.floor(Math.random() * (max - min + 1) + min)
        }

        window.onload = (event) => {
            console.log('Run func initGame()');
            initGame();
            console.log('isGridSudokuValid() = ' + isGridSudokuValid());

        };
    </script>
</head>

<body>
    <div class="container-fluid p-1 bg-primary text-white text-center">
        <h3>Welcome to my sudoku</h3>
    </div>

    <div class="container mt-1">
        <div class="row">
            <div class="d-flex justify-content-between">

                <div class="d-flex justify-content-start">
                    <div>Difficult:</div>
                    <div>
                        <select class="form-select border-0 pt-0">
                            <option value="1">Easy</option>
                            <option value="5">Medium</option>
                            <option value="10">Hard</option>
                            <option value="20">Expect</option>
                            <option value="30">Evil</option>
                            <option value="50">AI?</option>
                        </select>
                    </div>
                </div>

                <div>
                    <div class="form-check form-switch">
                        <label class="form-check-label" for="flexSwitchCheckChecked">Auto-check for mistakes</label>
                        <input class="form-check-input" type="checkbox" id="flexSwitchCheckChecked" checked>
                    </div>
                </div>

                <div>
                    <span>20:30</span>
                    <button type="button" class="btn btn-primary btn-circle btn-sm">
                        <i class="fa fa-pause" aria-hidden="true"></i>
                    </button>
                    <button type="button" class="btn btn-primary btn-circle btn-sm">
                        <i class="fa fa-play" aria-hidden="true"></i>
                    </button>
                </div>

            </div>
        </div>
    </div>

    <div class="container mt-1 border">
        <div class="row">
            <div class="col-6 mt-1 border">
                <Canvas class="mx-6" onmousemove="handleMouseMoveOn(event)" id="canvas" />
            </div>

            <div class="col-4">
                <div class="col-10 mt-1 border">
                    <div class="row">
                        <button type="button" class="btn btn-primary btn-lg  btn-block">New Game</button>
                    </div>

                    <div class="row mt-1">
                        <div class="col-3">
                            <button class="btn btn-circle btn-md btn-outline-primary">
                                <i class="fa fa-undo fa-3x"></i>
                            </button>
                            <p class="text-center">Undo</p>
                        </div>
                        <div class="col-3">
                            <button class="btn btn-circle btn-md btn-outline-primary">
                                <i class="fa fa-eraser fa-3x"></i>
                            </button>
                            <p class="text-center">Eraser</p>
                        </div>
                        <div class="col-3">
                            <button class="btn btn-lg btn-circle btn-md btn-outline-primary">
                                <i class="fa fa-pencil fa-3x"></i>
                            </button>
                            <p class="text-center">Pencil</p>
                        </div>
                        <div class="col-3">
                            <button class="btn btn-circle btn-md btn-outline-primary">
                                <i class="fa fa-lightbulb-o fa-3x"></i>
                            </button>
                            <p class="text-center">Hint</p>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-4">
                            <button type="button" class="btn btn-primary btn-square-md fs-1">1</button>
                        </div>
                        <div class="col-4">
                            <button type="button" class="btn btn-primary btn-square-md fs-1">2</button>
                        </div>
                        <div class="col-4">
                            <button type="button" class="btn btn-primary btn-square-md fs-1">3</button>
                        </div>
                    </div>
                    <div class="row mt-2">
                        <div class="col-4">
                            <button type="button" class="btn btn-primary btn-square-md fs-1">4</button>
                        </div>
                        <div class="col-4">
                            <button type="button" class="btn btn-primary btn-square-md fs-1">5</button>
                        </div>
                        <div class="col-4">
                            <button type="button" class="btn btn-primary btn-square-md fs-1">6</button>
                        </div>
                    </div>
                    <div class="row mt-2">
                        <div class="col-4">
                            <button type="button" class="btn btn-primary btn-square-md fs-1">7</button>
                        </div>
                        <div class="col-4">
                            <button type="button" class="btn btn-primary btn-square-md fs-1">8</button>
                        </div>
                        <div class="col-4">
                            <button type="button" class="btn btn-primary btn-square-md fs-1">9</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>

</html>